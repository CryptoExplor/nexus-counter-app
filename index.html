<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nexus Counter dApp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Farcaster Mini App Metadata (Simplified for demonstration) -->
    <meta name="fc:miniapp" content='{
        "version":"1",
        "imageUrl":"https://nexus-counter.vercel.app/image.png",
        "button":{
          "title":"Nexus Counter",
          "action":{
            "type":"launch_frame",
            "name":"LAUNCH",
            "url":"https://nexus-counter.vercel.app",
            "splashImageUrl":"https://nexus-counter.vercel.app/splash.png",
            "splashBackgroundColor":"#1B1B1E"
          }
        }
    }' />

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Inter Font for main text and Roboto Mono for addresses -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    
    <style>
        /* --- Color Configuration --- */
        :root {
            --background: #ffffff;
            --foreground: #171717;
            --subtle-bg: #f5f5f5;
            --subtle-text: #525252;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --background: #0a0a0a;
                --foreground: #ededed;
                --subtle-bg: #1f1f1f;
                --subtle-text: #a3a3a3;
            }
        }
        
        /* Custom styles */
        body {
            font-family: 'Inter', Arial, Helvetica, sans-serif; 
            color: var(--foreground);
            background: var(--background); 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background 0.3s, color 0.3s;
        }

        .font-mono {
            font-family: 'Roboto Mono', monospace; 
        }

        .app-card {
            background-color: var(--background);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .app-subtle-box {
            background-color: var(--subtle-bg);
        }

        /* --- Custom Counter Scaling --- */
        #counter-value {
          word-break: break-word;
          /* Responsive scaling: Min 3rem, Fluid 10vw, Max 6rem */
          font-size: clamp(3rem, 10vw, 6rem); 
        }

        /* Counter Pulse Animation */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        .counter-updated {
            animation: pulse 0.6s ease-in-out;
        }

        /* Counter Loading State */
        .counter-loading {
            opacity: 0.6;
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 relative">

    <div id="app-card" class="app-card p-8 md:p-12 rounded-xl w-full max-w-lg transition-all duration-300">
        
        <!-- Title & Subtitle -->
        <h1 class="text-3xl font-light tracking-tight mb-6 text-center">
            Nexus Counter
        </h1>
        <p class="text-center mb-8" style="color: var(--subtle-text);">
            A simple dApp on the Nexus network.
        </p>

        <!-- Status and User Meta -->
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 p-4 app-subtle-box rounded-lg">
            <div class="flex items-center mb-2 sm:mb-0">
                <span class="text-xs font-medium uppercase tracking-wider mr-2" style="color: var(--subtle-text);">Status:</span>
                <span id="status-meta" class="text-sm font-medium text-gray-500">Disconnected</span>
            </div>
            <div class="flex items-center">
                <span class="text-xs font-medium uppercase tracking-wider mr-2" style="color: var(--subtle-text);">Wallet:</span>
                <span id="user-meta" class="text-sm font-mono" style="color: var(--foreground);">Not Connected</span>
            </div>
        </div>

        <!-- Counter Value Display -->
        <div class="text-center my-10">
            <!-- Tailwind sizing classes (text-7xl, md:text-8xl) removed to allow CSS clamp() to control the size -->
            <p class="font-black counter-glow transition-colors duration-500" id="counter-value">
                0
            </p>
            <p class="text-xs mt-2" style="color: var(--subtle-text);">Current contract value</p>
        </div>

        <!-- Badge Tier Display -->
        <div id="badge-tier-container" class="text-center -mt-6 mb-8 hidden">
             <span id="badge-tier" class="text-lg font-semibold text-indigo-600 dark:text-indigo-400"></span>
        </div>

        <!-- Action Area -->
        <div class="flex flex-col space-y-4">
            
            <!-- Connect/Switch/Connected Button -->
            <button id="connect-btn" class="w-full py-3 px-6 text-lg font-medium rounded-full bg-black hover:bg-gray-800 text-white shadow-xl transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 active:scale-[0.98]">
                Connect Wallet
            </button>

            <!-- Increment/Decrement Group (hidden initially) -->
            <div id="inc-dec-group" class="hidden flex space-x-4">
                <button id="decrement-btn" disabled class="flex-1 py-3 px-6 text-lg font-medium rounded-full bg-red-600 hover:bg-red-700 text-white shadow-xl transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50 disabled:bg-red-400 disabled:cursor-not-allowed active:scale-[0.98]">
                    Decrement
                </button>
                <button id="increment-btn" disabled class="flex-1 py-3 px-6 text-lg font-medium rounded-full bg-green-600 hover:bg-green-700 text-white shadow-xl transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50 disabled:bg-green-400 disabled:cursor-not-allowed active:scale-[0.98]">
                    Increment
                </button>
            </div>
        </div>

        <!-- Admin Controls -->
        <div id="admin-controls" class="hidden p-4 border rounded-xl bg-gray-50 dark:bg-gray-800 mt-6">
            <h2 class="text-lg font-semibold mb-2 text-center text-red-600 dark:text-red-400">Admin Controls (Owner Only)</h2>
            <button id="reset-btn" class="w-full px-4 py-3 bg-red-600 text-white rounded-lg font-medium hover:bg-red-700 transition duration-300">Reset Counter</button>
        </div>

        <!-- Leaderboard -->
        <div id="leaderboard-container" class="hidden mt-6 p-4 border border-gray-200 dark:border-gray-700 rounded-xl app-subtle-box">
            <h2 class="text-lg font-semibold mb-3 text-center">Top 20 Leaderboard</h2>
            <!-- Leaderboard List -->
            <div id="leaderboard-list" class="space-y-1"></div>
            <!-- User Rank Display -->
            <div id="user-rank" class="mt-4 text-center text-sm font-semibold text-indigo-600 dark:text-indigo-400"></div>
        </div>

        <!-- Message/Error Display (hidden initially) -->
        <div id="message-container" class="mt-6 p-3 rounded-xl text-center hidden">
            <div id="message-text" class="font-medium"></div>
            <div id="tx-details" class="mt-2 text-sm flex justify-center items-center gap-2 hidden">
                <a id="tx-link" target="_blank" rel="noopener noreferrer" class="font-mono text-indigo-600 dark:text-indigo-400 hover:underline"></a>
                <!-- Copy Button -->
                <button id="copy-btn" data-hash="" class="flex items-center text-xs px-2 py-1 rounded bg-indigo-100 text-indigo-700 hover:bg-indigo-200 transition duration-200" title="Copy Transaction Hash">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M7 9a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2H9a2 2 0 01-2-2V9z" />
                        <path d="M5 3a2 2 0 00-2 2v6a2 2 0 002 2V5h6a2 2 0 00-2-2H5z" />
                    </svg>
                    Copy Hash
                </button>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="absolute bottom-0 left-0 right-0 flex justify-center gap-6 py-4" style="color: var(--subtle-text);">
        <a href="https://farcaster.xyz/dare1.eth" target="_blank" aria-label="Farcaster">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"/><path d="M12 7c-2.757 0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3 3 1.346 3 3-1.346 3-3 3z"/></svg>
        </a>
        <a href="https://x.com/kumar14700" target="_blank" aria-label="Twitter">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16" fill="currentColor"><path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z"/></svg>
        </a>
    </footer>


    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
    <script type="module">
        import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
        import EthereumProvider from 'https://esm.sh/@walletconnect/ethereum-provider';
        
        // --- IMPORTANT: CONFIGURE YOUR PROJECT ID ---
        const WALLETCONNECT_PROJECT_ID = "e0dd881bad824ac3418617434a79f917"; 
        
        // --- Contract Details (loaded from JSON) ---
        let CONTRACT_ADDRESS;
        let CONTRACT_ABI;
        let configLoadedSuccessfully = false; // New flag
        
        // --- NEXUS TESTNET CONFIGURATION ---
        const NEXUS_CHAIN_ID_DEC = 3940;
        const NEXUS_CHAIN_ID_HEX = '0xf64';
        // Note: Replace with your actual RPC URL if this one is rate-limited
        const NEXUS_RPC_URL = 'https://nexus-testnet.g.alchemy.com/v2/d5bxPxUVzMKqbZ2CA4EZi'; 
        const EXPLORER_URL = 'https://testnet3.explorer.nexus.xyz';
        const NATIVE_CURRENCY = { name: 'NEX', symbol: 'NEX', decimals: 18 };

        // --- UI Element References ---
        const ui = {
            counterValue: document.getElementById('counter-value'),
            connectBtn: document.getElementById('connect-btn'),
            incDecGroup: document.getElementById('inc-dec-group'),
            incrementBtn: document.getElementById('increment-btn'),
            decrementBtn: document.getElementById('decrement-btn'),
            userMeta: document.getElementById('user-meta'),
            badgeTierContainer: document.getElementById('badge-tier-container'),
            badgeTier: document.getElementById('badge-tier'),
            messageContainer: document.getElementById('message-container'),
            messageText: document.getElementById('message-text'),
            txDetails: document.getElementById('tx-details'),
            txLink: document.getElementById('tx-link'),
            copyBtn: document.getElementById('copy-btn'),
            statusMeta: document.getElementById('status-meta'),
            adminControls: document.getElementById('admin-controls'),
            resetBtn: document.getElementById('reset-btn'),
            leaderboardContainer: document.getElementById('leaderboard-container'),
            leaderboardList: document.getElementById('leaderboard-list'),
            userRank: document.getElementById('user-rank'),
        };

        // --- State variables ---
        let provider, signer, contract, readContract;
        let userAddress = null;
        let isConnecting = false;
        let currentProviderInstance = null;
        let messageTimeoutId = null;
        let autoRefreshInterval = null;

        /**
         * Loads contract address and ABI from contract.json.
         */
        async function loadContractConfig() {
            try {
                // IMPORTANT: In a real deployment, ensure contract.json is accessible.
                const response = await fetch('/contract.json'); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                CONTRACT_ADDRESS = data.address;
                CONTRACT_ABI = data.abi;
                configLoadedSuccessfully = true;
            } catch (error) {
                // FALLBACK: Use a hardcoded, minimal placeholder ABI if loading failed,
                // but rely on configLoadedSuccessfully=false to stop connection later.
                CONTRACT_ADDRESS = "0x148Ed472d09565Db0aAa3b4a8c521fCB41d132Fa"; // Generic fake address
                CONTRACT_ABI = [
                    "function getCount() view returns (uint256)",
                    "function fee() view returns (uint256)",
                    "function increment() payable",
                    "function decrement() payable",
                    "function resetCounter(uint256)",
                    "function owner() view returns (address)", 
                    "function getUserStats(address) view returns (uint256, uint256, uint256, uint256)",
                    "function getTopAddresses() view returns (address[])", 
                    "function getTopCounts() view returns (uint256[])", 
                ]; 
                
                if (error.message.includes('HTTP error!')) {
                    console.error("Could not load contract.json. Using generic placeholder ABI/Address to prevent runtime errors on contract object creation.", error);
                    displayMessage("Warning: Contract config failed to load. Please ensure 'contract.json' is deployed correctly.", 'error');
                } else {
                    console.error("Fatal Error: Could not load contract.json.", error);
                    displayMessage("Could not load contract configuration.", 'error');
                }
            }
        }

        /**
         * Creates a singleton instance of the read-only contract.
         */
        async function getReadContract() {
            if (!readContract) {
                const readProvider = new ethers.JsonRpcProvider(NEXUS_RPC_URL);
                readContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
            }
            return readContract;
        }

        // --- Smart Auto-Refresh Functions ---
        function startAutoRefresh() {
            if (autoRefreshInterval) return; // already running
            autoRefreshInterval = setInterval(async () => {
                // Ensure we have a contract instance and user is connected before refreshing
                if (contract && userAddress) { 
                    const prevValue = ui.counterValue.textContent;
                    await updateCount(false);
                    // Only update badge and leaderboard if counter value changed
                    if (ui.counterValue.textContent !== "Error" && ui.counterValue.textContent !== prevValue) {
                        await updateBadge();
                        await fetchLeaderboard();
                    }
                    updateAdminUI(); 
                }
            }, 5000); // refresh every 5 seconds
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // --- Utility Functions ---
        function normalizeChainId(chainId) {
            if (!chainId) return BigInt(-1);
            if (typeof chainId === 'bigint') return chainId;
            if (typeof chainId === 'number') return BigInt(chainId);
            return BigInt(chainId.toString());
        }

        function isFarcasterMiniApp() {
            return window?.navigator?.userAgent?.includes("Farcaster") || window?.fcMiniApp !== undefined;
        }

        function formatAddress(addr) {
            return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : "Not Connected";
        }

        function formatHash(hash) {
            return hash ? `${hash.slice(0, 6)}...${hash.slice(-4)}` : "";
        }
        
        function setStatus(text, colorClass) {
            ui.statusMeta.textContent = text;
            // Remove existing color classes
            ui.statusMeta.className = ui.statusMeta.className.split(' ').filter(c => !c.startsWith('text-')).join(' ');
            ui.statusMeta.classList.add(colorClass);
        }

        function setActionButtonsEnabled(enabled) {
            // Only enable if userAddress is present (connected) and 'enabled' is true
            const shouldEnable = enabled && !!userAddress; 
            ui.incrementBtn.disabled = !shouldEnable;
            ui.decrementBtn.disabled = !shouldEnable;
            
            if (shouldEnable) {
                ui.incDecGroup.classList.remove('hidden');
                ui.incDecGroup.classList.add('flex');
            } else {
                ui.incDecGroup.classList.add('hidden');
                ui.incDecGroup.classList.remove('flex');
            }
        }
        
        function updateConnectButton(state) {
            ui.connectBtn.disabled = false;
            ui.connectBtn.onclick = null;
            ui.connectBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'bg-black', 'hover:bg-gray-800');
            switch (state) {
                case 'CONNECTED':
                    ui.connectBtn.textContent = 'Wallet Connected';
                    ui.connectBtn.disabled = true; 
                    ui.connectBtn.classList.add('bg-black');
                    break;
                case 'WRONG_NETWORK':
                    ui.connectBtn.textContent = 'Switch to Nexus Testnet';
                    ui.connectBtn.onclick = switchToNexus;
                    ui.connectBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    break;
                case 'LOADING':
                    ui.connectBtn.textContent = 'Connecting...';
                    ui.connectBtn.disabled = true;
                    ui.connectBtn.classList.add('bg-black');
                    break;
                case 'DISCONNECTED':
                default:
                    ui.connectBtn.textContent = 'Connect Wallet';
                    ui.connectBtn.onclick = connectWallet;
                    ui.connectBtn.classList.add('bg-black', 'hover:bg-gray-800');
                    break;
            }
        }

        function displayMessage(message, type = 'info', hash = null) {
            let baseClasses = 'mt-6 p-3 rounded-xl text-center transition-all duration-300';
            let duration = 5000;
            if (messageTimeoutId) clearTimeout(messageTimeoutId);
            ui.txDetails.classList.add('hidden'); 
            switch (type) {
                case 'error': baseClasses += ' bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300'; duration = 8000; break;
                case 'success': baseClasses += ' bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300'; break;
                default: baseClasses += ' bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300'; break;
            }
            ui.messageContainer.className = baseClasses;
            ui.messageText.textContent = message;
            ui.messageContainer.classList.remove('hidden');
            if (hash) {
                ui.txLink.href = `${EXPLORER_URL}/tx/${hash}`; 
                ui.txLink.textContent = formatHash(hash);
                ui.txDetails.classList.remove('hidden');
                ui.copyBtn.setAttribute('data-hash', hash); 
            }
            messageTimeoutId = setTimeout(() => {
                ui.messageContainer.classList.add('hidden');
            }, duration);
        }
        
        function copyToClipboard(text) {
            navigator.clipboard ? navigator.clipboard.writeText(text).then(() => displayMessage('Transaction hash copied!', 'success'), () => fallbackCopy(text)) : fallbackCopy(text);
        }

        function fallbackCopy(text) {
            const tempInput = document.createElement('input');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                // document.execCommand('copy') is the fallback method
                document.execCommand('copy') ? displayMessage('Transaction hash copied!', 'success') : displayMessage('Failed to copy hash.', 'error');
            } catch (err) {
                displayMessage('Failed to copy hash.', 'error');
            }
            document.body.removeChild(tempInput);
        }

        function addSpinner(buttonElement, originalText) {
            buttonElement.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>${originalText}...`;
        }
        
        // --- Feature Functions ---

        /**
         * Toggles the visibility of admin controls by checking the contract's owner.
         */
        async function updateAdminUI() {
            if (!userAddress || !configLoadedSuccessfully) {
                ui.adminControls.style.display = "none";
                return;
            }
            try {
                const readOnlyContract = await getReadContract();
                const ownerAddress = await readOnlyContract.owner(); 
                const isOwner = userAddress.toLowerCase() === ownerAddress.toLowerCase();
                ui.adminControls.style.display = isOwner ? "block" : "none";
            } catch (e) {
                console.error("Failed to check owner status:", e);
                ui.adminControls.style.display = "none";
            }
        }

        /**
         * Fetches and displays the top 20 users from the contract.
         */
        async function fetchLeaderboard() {
            if (!configLoadedSuccessfully) return;

            try {
                const readOnlyContract = await getReadContract();
                
                // CRITICAL FIX: Calling separate contract functions
                const addresses = await readOnlyContract.getTopAddresses();
                const counts = await readOnlyContract.getTopCounts();

                ui.leaderboardList.innerHTML = "";
                
                if(addresses.length === 0){
                    ui.leaderboardList.innerHTML = `<p class="text-sm text-gray-500 text-center">No entries yet.</p>`;
                } else {
                    for (let i = 0; i < addresses.length; i++) {
                        // Dynamically format list items
                        const isCurrentUser = userAddress && addresses[i].toLowerCase() === userAddress.toLowerCase();
                        const rowClass = isCurrentUser 
                            ? 'bg-indigo-100 dark:bg-indigo-900 ring-2 ring-indigo-500' // Highlight current user
                            : i % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'app-subtle-box'; // Alternate subtle background
                        
                        ui.leaderboardList.innerHTML += `<div class="flex justify-between items-center text-sm p-3 rounded-md transition-colors duration-200 ${rowClass}">
                            <span class="font-mono text-sm">${i + 1}. ${formatAddress(addresses[i])}</span>
                            <span class="font-bold text-lg">${counts[i].toString()}</span>
                        </div>`;
                    }
                }
                ui.leaderboardContainer.style.display = "block";
                
                // Note: Since getUserRank() is not exposed, we only show the leaderboard list. 
                ui.userRank.textContent = "";

            } catch (e) {
                console.error("Leaderboard error:", e);
                // Only hide if the error is severe, otherwise keep the container visible
                if (e.message?.includes('call revert exception')) {
                     ui.leaderboardContainer.style.display = "none";
                }
            }
        }
        
        /**
         * Fetches user stats and updates the badge tier display using the tier value (index 3).
         */
        async function updateBadge() {
            if (!userAddress || !configLoadedSuccessfully) {
                ui.badgeTierContainer.classList.add('hidden');
                return;
            }
            try {
                const readOnlyContract = await getReadContract();
                // Call getUserStats which returns (increments, decrements, lastAction, tier)
                const stats = await readOnlyContract.getUserStats(userAddress);
                const tierValue = Number(stats[3]); // tier is the 4th element (index 3)
                
                let tierText = "No Badge";
                // Contract Tiers: 1:Bronze(10), 2:Silver(25), 3:Gold(50), 4:Platinum(100), 5:Diamond(250), 6:Master(500), 7:Legendary(1000)
                if (tierValue === 7) tierText = "🌟 Legendary Badge (1000+ Actions)";
                else if (tierValue === 6) tierText = "💎 Master Badge (500+ Actions)";
                else if (tierValue === 5) tierText = "🔷 Diamond Badge (250+ Actions)";
                else if (tierValue === 4) tierText = "🪙 Platinum Badge (100+ Actions)";
                else if (tierValue === 3) tierText = "🥇 Gold Badge (50+ Actions)";
                else if (tierValue === 2) tierText = "🥈 Silver Badge (25+ Actions)";
                else if (tierValue === 1) tierText = "🥉 Bronze Badge (10+ Actions)";
                
                ui.badgeTier.textContent = tierText;
                
                // Show container if tier is greater than 0
                tierValue > 0
                    ? ui.badgeTierContainer.classList.remove('hidden')
                    : ui.badgeTierContainer.classList.add('hidden');

            } catch (e) {
                console.error("Failed to fetch badge tier:", e);
                ui.badgeTierContainer.classList.add('hidden');
            }
        }

        // --- Core Connection and Contract Setup ---
        async function initProvider() {
            if (isFarcasterMiniApp()) {
                sdk.actions.ready({ disableNativeGestures: true });
                if (!sdk.ethereum) throw new Error("Farcaster SDK Ethereum provider not available.");
                currentProviderInstance = sdk.ethereum;
            } else {
                if (WALLETCONNECT_PROJECT_ID.includes("YOUR_WALLETCONNECT_PROJECT_ID")) {
                     displayMessage('ERROR: WalletConnect Project ID is required.', 'error');
                     throw new new Error("Missing WalletConnect Project ID");
                }
                const wcProvider = await EthereumProvider.init({
                    projectId: WALLETCONNECT_PROJECT_ID,
                    chains: [NEXUS_CHAIN_ID_DEC], 
                    showQrModal: true,
                    rpc: { [NEXUS_CHAIN_ID_DEC]: NEXUS_RPC_URL }
                });
                
                // Event listeners for WalletConnect provider
                wcProvider.on("accountsChanged", async (accounts) => {
                    // This handles wallet changes without full reload
                    if (accounts.length > 0) await connectWallet(true); else window.location.reload(); 
                });
                wcProvider.on("chainChanged", async (chainId) => {
                    if (normalizeChainId(chainId) !== normalizeChainId(NEXUS_CHAIN_ID_DEC)) {
                        setStatus('Wrong Network', 'text-red-500');
                        updateConnectButton('WRONG_NETWORK');
                        setActionButtonsEnabled(false);
                        stopAutoRefresh();
                    } else {
                        // Re-initialize provider on correct chain change
                        await connectWallet(true); 
                    }
                });
                wcProvider.on("disconnect", () => {
                    // Force a reload on disconnect for a clean state
                    stopAutoRefresh();
                    window.location.reload();
                });

                // Attempt to connect immediately. This is the part that opens the QR code.
                await wcProvider.connect();
                currentProviderInstance = wcProvider;
            }

            // After a successful connection/provider setup:
            provider = new ethers.BrowserProvider(currentProviderInstance);
            signer = await provider.getSigner();
            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
            userAddress = await signer.getAddress();
            
            const network = await provider.getNetwork();
            if (normalizeChainId(network.chainId) !== normalizeChainId(NEXUS_CHAIN_ID_DEC)) {
                throw new Error('Wrong Network: ' + network.chainId.toString(10));
            }

            // Everything succeeded, update UI and start operations
            ui.userMeta.textContent = formatAddress(userAddress);
            setStatus('Connected to Nexus Testnet', 'text-green-600');
            updateConnectButton('CONNECTED');
            setActionButtonsEnabled(true);
            
            await updateCount(true);
            await updateBadge();
            await updateAdminUI(); 
            fetchLeaderboard(); 
            startAutoRefresh();
        }

        async function switchToNexus() {
            if (isConnecting || !currentProviderInstance) return;
            isConnecting = true;
            updateConnectButton('LOADING');
            try {
                await currentProviderInstance.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: NEXUS_CHAIN_ID_HEX }] });
                await connectWallet(true); // Force re-init after switch
            } catch (error) {
                if (error.code === 4902) {
                    try {
                        await currentProviderInstance.request({ method: 'wallet_addEthereumChain', params: [{ chainId: NEXUS_CHAIN_ID_HEX, chainName: 'Nexus Testnet', rpcUrls: [NEXUS_RPC_URL], blockExplorerUrls: [EXPLORER_URL], nativeCurrency: NATIVE_CURRENCY }] });
                        await connectWallet(true);
                    } catch (addError) {
                        displayMessage('Failed to add Nexus Testnet.', 'error');
                    }
                } else {
                    displayMessage(error.code === 4001 ? "Network switch rejected." : "Failed to switch networks.", 'error');
                }
                updateConnectButton('WRONG_NETWORK');
            } finally { isConnecting = false; }
        }

        async function connectWallet(isRetry = false) {
            if (isConnecting && !isRetry) return;
            isConnecting = true;
            updateConnectButton('LOADING');
            
            // Critical check: Stop connection if config isn't loaded
            if (!configLoadedSuccessfully) {
                displayMessage("Configuration Missing: Please deploy 'contract.json' and refresh.", 'error');
                isConnecting = false;
                // Re-run window.onload logic to ensure UI state is correct for disconnected/failed config
                await window.onload(); 
                return;
            }

            try {
                await initProvider();
            } catch (e) {
                console.error("Connection failed:", e);
                userAddress = null;
                ui.userMeta.textContent = 'Not Connected';
                if (e.message?.includes('Wrong Network')) {
                     setStatus('Wrong Network', 'text-red-500');
                     updateConnectButton('WRONG_NETWORK');
                } else {
                    const msg = e.message?.includes('rejected') || e.message?.includes('closed') ? 'Connection rejected.' : 'Connection failed.';
                    displayMessage(msg, 'error');
                    setStatus('Disconnected', 'text-gray-500');
                    updateConnectButton('DISCONNECTED');
                }
                setActionButtonsEnabled(false);
            } finally { isConnecting = false; }
        }

        async function updateCount(triggerAnimation = false) {
            if (!configLoadedSuccessfully) {
                ui.counterValue.textContent = "Config Error";
                return;
            }

            ui.counterValue.classList.add("counter-loading");
            try {
                const contract = await getReadContract();
                const value = await contract.getCount();
                const newValue = value.toString();
                if (ui.counterValue.textContent !== newValue && triggerAnimation) {
                    ui.counterValue.classList.add("counter-updated");
                    setTimeout(() => ui.counterValue.classList.remove("counter-updated"), 600);
                }
                ui.counterValue.textContent = newValue;
            } catch (e) {
                // More helpful error message for the user based on the screenshot
                ui.counterValue.textContent = "Error";
                console.error("Read count error:", e);
                if (triggerAnimation) displayMessage("Failed to read counter value. Check contract address/ABI.", 'error');
            } finally {
                ui.counterValue.classList.remove("counter-loading");
            }
        }

        /**
         * Sends a transaction to increment or decrement the counter.
         */
        async function sendTransaction(methodName, buttonElement, originalText) {
            if (!contract || buttonElement.disabled || !configLoadedSuccessfully) return;
            setActionButtonsEnabled(false);
            addSpinner(buttonElement, originalText);
            setStatus('Awaiting Signature...', 'text-yellow-600');
            ui.messageContainer.classList.add('hidden'); 
            try {
                // 1. Fetch the exact required fee from the contract
                const readOnlyContract = await getReadContract();
                const fee = await readOnlyContract.fee();
                
                // 2. Send the transaction, including the fee in the 'value' field
                const tx = await contract[methodName]({ value: fee });
                
                buttonElement.textContent = 'Waiting for Tx...';
                setStatus('Transaction sent, waiting for mining...', 'text-orange-600');
                const receipt = await tx.wait();
                if (receipt && receipt.status === 1) {
                    displayMessage('Transaction successful!', 'success', tx.hash);
                    setStatus('Connected to Nexus Testnet', 'text-green-600');
                    await updateCount(true); 
                    await updateBadge();
                    await fetchLeaderboard();
                } else {
                    displayMessage('Transaction failed on the blockchain.', 'error', tx.hash);
                }
            } catch (e) {
                // Extract reason, error code, or message
                const reason = e.reason || e.code || e.message || 'Transaction failed.';
                let displayReason = reason;

                // CRITICAL FIX: Handle the specific timeLocked() revert message
                if (reason.includes("Action locked: wait")) {
                    displayReason = "Action blocked: Please wait 1 hour between actions (cooldown enforced by contract).";
                } else if (reason.includes('already zero')) {
                    displayReason = "Decrement failed: Counter is already zero.";
                } else if (reason.includes('rejected') || reason === 'ACTION_REJECTED') {
                    displayReason = 'Transaction rejected by wallet.';
                } else {
                     // For general errors, just show the core message
                    displayReason = displayReason.split('(')[0].trim();
                }

                displayMessage(displayReason, 'error');

                if (userAddress) setStatus('Connected to Nexus Testnet', 'text-green-600');
            } finally {
                setActionButtonsEnabled(true);
                buttonElement.textContent = originalText;
            }
        }
        
        // --- Initialization and Event Listeners Setup ---
        const incrementCounter = () => sendTransaction('increment', ui.incrementBtn, 'Increment');
        const decrementCounter = () => sendTransaction('decrement', ui.decrementBtn, 'Decrement');
        
        ui.connectBtn.onclick = connectWallet; 
        ui.incrementBtn.onclick = incrementCounter;
        ui.decrementBtn.onclick = decrementCounter;
        ui.copyBtn.onclick = () => copyToClipboard(ui.copyBtn.getAttribute('data-hash'));

        // --- Admin Reset Button Handler ---
        ui.resetBtn.onclick = async () => {
            if (!configLoadedSuccessfully) return;

            // Note: We don't need to check for admin status here as the contract will revert if msg.sender is not the owner
            const newValueStr = prompt("Enter new counter value:");
            if (newValueStr !== null) {
                const newValue = Number(newValueStr);
                if (!isNaN(newValue) && Number.isInteger(newValue)) {
                    try {
                        const tx = await contract.resetCounter(newValue);
                        displayMessage("Resetting counter...", "info");
                        await tx.wait();
                        displayMessage("Counter reset successfully!", "success");
                        await updateCount(true);
                        await fetchLeaderboard();
                    } catch (e) {
                        const reason = e.reason || e.message || 'Reset failed.';
                        // User-friendly error message for onlyOwner check
                        const displayReason = reason.includes('Ownable') ? 'Reset failed: Only the contract owner can call this function.' : reason;
                        displayMessage("Reset failed: " + displayReason, "error");
                    }
                } else {
                    displayMessage("Invalid input. Please enter a whole number.", "error");
                }
            }
        };
        // --- End Admin Reset Button Handler ---

        window.onload = async () => {
            // First, try to load configuration
            await loadContractConfig();
            
            // Check if loading failed or the placeholder address is still used
            if (!configLoadedSuccessfully) {
                // If config fails, prevent connection and show error
                setStatus('Config Error: Missing contract.json', 'text-red-500');
                ui.counterValue.textContent = "Config Error";
                updateConnectButton('DISCONNECTED');
                ui.connectBtn.disabled = true;
                setActionButtonsEnabled(false);
                return;
            }
            
            // Initial read of the counter (will be '0' or the actual count if successful)
            await updateCount(false);
            
            // Fetch leaderboard on initial load (optional, but good if contract is live)
            fetchLeaderboard(); 
            
            // If we successfully loaded config, prepare to connect
            setStatus('Ready to connect', 'text-gray-500');
            updateConnectButton('DISCONNECTED');
            setActionButtonsEnabled(false);
        }
    </script>
</body>
</html>
